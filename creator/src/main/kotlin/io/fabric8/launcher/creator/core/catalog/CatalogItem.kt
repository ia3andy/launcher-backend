package io.fabric8.launcher.creator.core.catalog

import io.fabric8.launcher.creator.core.*
import io.fabric8.launcher.creator.core.maven.maven
import io.fabric8.launcher.creator.core.nodejs.mergePackageJson as mergePackage
import io.fabric8.launcher.creator.core.resource.Resources
import io.fabric8.launcher.creator.core.template.Transformer
import io.fabric8.launcher.creator.core.template.transformFiles
import java.nio.file.*

val PATH_FILES: Path = Paths.get("files")
val PATH_POM: Path = Paths.get("pom.xml")
val PATH_MERGE_POM: Path = Paths.get("merge/pom.xml")
val PATH_PACKAGE: Path = Paths.get("package.json")
val PATH_MERGE_PACKAGE: Path = Paths.get("merge/package.json")
val PATH_NONE: Path = Paths.get("")

interface CatalogItem {
    fun apply(resources: Resources, props: Properties, extra: Properties): Resources
}

class CatalogItemContext(val targetDir: Path)

abstract class BaseCatalogItem(private val ctx: CatalogItemContext) : CatalogItem {
    protected val sourceDir: Path
        get() = Paths.get(this.javaClass.`package`.name.replace('.', '/')
                + "/" + this.javaClass.simpleName.toLowerCase())

    protected val targetDir: Path
        get() = ctx.targetDir

    protected fun <T : Generator> generator(genconst: (CatalogItemContext) -> T): T {
        return genconst(ctx)
    }

    protected fun name(vararg parts: Any?): String {
        return parts.filterNotNull().joinToString("-")
    }

    protected fun copy(from: Path = PATH_FILES, to: Path? = null) {
        val from2 = resolveClassPath(sourceDir.resolve(from))
        val to2 = resolveClassPath(if (to != null) targetDir.resolve(to) else targetDir)
        Files.walk(from2).forEach {
            if (!Files.isDirectory(it)) {
                val rel = from2.relativize(it)
                val target = to2.resolve(rel.toString())
                Files.createDirectories(target.parent)
                Files.copy(it, target, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES)
            }
        }
    }

    protected fun filesCopied(from: Path = PATH_FILES, to: Path? = null): Boolean {
        val from2 = resolveClassPath(sourceDir.resolve(from))
        val to2 = resolveClassPath(if (to != null) targetDir.resolve(to) else targetDir)
        return Files.walk(from2).allMatch {
            val rel = from2.relativize(it)
            val target = to2.resolve(rel.toString())
            Files.exists(target)
        }
    }

    protected fun move(original: Path, to: Path) {
        val original2 = targetDir.resolve(original)
        val to2 = targetDir.resolve(to)
        Files.move(original2, to2, StandardCopyOption.REPLACE_EXISTING)
    }

    protected fun transform(pattern: String, transformer: Transformer, dir: Path = PATH_NONE) {
        transformFiles(resolveClassPath(targetDir.resolve(dir)), pattern, transformer)
    }

    protected fun transform(patterns: List<String>, transformer: Transformer, dir: Path = PATH_NONE) {
        transformFiles(resolveClassPath(targetDir.resolve(dir)), patterns, transformer)
    }

    protected fun appendFile(targetFile: Path, sourceFile: Path) {
        val txt = streamFromPath(sourceDir.resolve(sourceFile)).use {
            it.bufferedReader().readText()
        }
        targetDir.resolve(targetFile).toFile().appendText(txt)
    }

    protected fun updatePom(appName: String, groupId: String, artifactId: String, version: String, pomFile: Path = PATH_POM) {
        maven.updateMetadata(targetDir.resolve(pomFile), appName, "Generated Application '$appName'")
        maven.updateGAV(targetDir.resolve(pomFile), groupId, artifactId, version)
    }

    protected fun mergePoms(sourcePom: Path = PATH_MERGE_POM, targetPom: Path = PATH_POM) {
        maven.mergePoms(targetDir.resolve(targetPom), sourceDir.resolve(sourcePom))
    }

    protected fun mergeVersionPoms(runtime: Runtime, targetPom: Path = PATH_POM) {
        val sourcePom = Paths.get("merge/pom.${validRuntime(runtime).version}.xml")
        if (existsFromPath(sourceDir.resolve(sourcePom))) {
            mergePoms(sourcePom, targetPom)
        }
    }

    protected fun updateMetadata(name: String, description: String = "A new application generated by the Red Hat Application Creator", pomFile: Path = PATH_POM) {
        maven.updateMetadata(targetDir.resolve(pomFile), name, description)
    }

    protected fun mergePackageJson(source: Path = PATH_MERGE_PACKAGE, target: Path = PATH_PACKAGE) {
        mergePackage(targetDir.resolve(target), sourceDir.resolve(source))
    }
}
